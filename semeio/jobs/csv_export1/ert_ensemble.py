from semeio.jobs.csv_export1.ert_member import ErtMember
from operator import attrgetter


class ErtEnsemble(object):
    """ErtEnsemble: A utility base class for loading an external ensemble.

    When using workflows in ERT it is a quite common scenario that we
    wish to iterate through all the realisations and calculate
    aggregated results of some kind. The purpose of the ErtEnsemble
    class is to serve as baseclass utility for that sort of
    workflows. The ErtEnsemble class handles the book keeping required
    to iterate through all the realisation folders, and implements
    querying of realisations based on realisation number and
    iteration.

    The code for actually \'doing something interesting\' should be
    implemented by implementing a derived class which must have the
    method \'load_data\'. Consider for example that we want a workflow
    which goes through all the realisations and ask for the TCPU field
    in the summary results; we could implement this with a
    TCPUEnsemble class which derives from the ErtEnsemble class:


       class TCPUEnsemble(ErtEnsemble):

          def load_data(self , member):
              sum = EclSum( "%s/%s" (member.path , member.case))
              self.data = sum.get_last_value("TCPU")

    """

    def __init__(self, path_file):
        self.__ensemble = []
        self.__has_iterations = False
        self.verbose = True
        self.__refcase = None
        if path_file:
            self.load(path_file)

    def __len__(self):
        return len(self.__ensemble)

    def __getitem__(self, index):
        try:
            return self.__ensemble[index]
        except IndexError:
            raise IndexError("Realization number '%d' not available" % index)

    def __iter__(self):
        for member in self.__ensemble:
            yield member

    def add(self, ensemble_member):
        self.__ensemble.append(ensemble_member)

    def getMembers(self, iens=None, iteration=None):
        if iens is None and iteration is not None:
            unsorted = list(filter(lambda x: x.iteration == iteration, self.__ensemble))
            return sorted(unsorted, key=lambda r: r.iens)

        if iens is not None and iteration is None:
            unsorted = list(filter(lambda x: x.iens == iens, self.__ensemble))
            return sorted(unsorted, key=lambda r: r.iteration)

        if iens is not None and iteration is not None:
            unsorted = list(
                filter(
                    lambda x: x.iens == iens and x.iteration == iteration,
                    self.__ensemble,
                )
            )
            return sorted(unsorted, key=lambda r: (r.iteration, r.iens))

        return sorted(self.__ensemble, key=lambda r: (r.iteration, r.iens))

    def getMember(self, iens, iteration):
        members = self.getMembers(iens, iteration)
        mem = members[0]
        assert isinstance(mem, ErtMember)
        return mem

    def load(self, path_file):
        """Iterate through all the realisation folder in the @path_file.

        The @path_file is a simple text file with one line for each
        realisation, each line contains the four columns realisation
        number, path, case name and iteration - i.e. something like:

          0  /path/to/case/0  CASE-0000 0
          1  /path/to/case/1  CASE-0001 0

        This file is typically generated by the RUNPATH_LIST mechanism
        in the main ERT application, and the path to this file is
        typically passed to the worklfow by using the <RUNPATH_LIST>
        \"magic string\"; however in principle you can create the
        path_file by other means.
        """
        fileH = open(path_file, "r")
        for line in fileH.readlines():
            line = line.strip()
            if line:
                tmp = line.split()
                iens = int(tmp[0])
                path = tmp[1]
                case_name = tmp[2]
                if len(tmp) >= 4:
                    iteration = int(tmp[3])
                    self.__has_iterations = True
                else:
                    iteration = 0

                mem = ErtMember(iens, path, case_name, iteration)

                if hasattr(self, "load_data"):
                    try:
                        self.load_data(mem)
                    except (IOError, AssertionError):
                        print(
                            "Warning: Something went wrong when loading realization %s iteration %s, skipping this case!"
                            % (mem.iens, mem.iteration)
                        )
                        continue

                    if mem and not self.__refcase:
                        self.__refcase = mem
                else:
                    mem.data = True

                self.add(mem)

    @property
    def refcase(self):
        return self.__refcase

    def getMaxRealizationNumber(self):
        value = max(self.__ensemble, key=attrgetter("iens"))
        return value.iens

    def hasIterations(self):
        iterations = self.getIterations()
        res = not (len(iterations) == 1 and iterations[0] == 0)
        return res

    def getIterations(self):
        return sorted(set(member.iteration for member in self.__ensemble))

    def filter(self, iens=None, iteration=None, has_data=None):
        member_list = []
        for mem in self:
            if not iens is None:
                if mem.iens != iens:
                    continue

            if not iteration is None:
                if mem.iteration != iteration:
                    continue

            if not has_data is None:
                if has_data == True:
                    if mem.data is None:
                        continue
                elif has_data == False:
                    if not mem.data is None:
                        continue

            member_list.append(mem)

        return member_list
